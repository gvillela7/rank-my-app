// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"context"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"github.com/gvillela7/rank-my-app/configs"
	"github.com/gvillela7/rank-my-app/internal/adapter/http/handlers"
	"github.com/gvillela7/rank-my-app/internal/adapter/http/routes"
	"github.com/gvillela7/rank-my-app/internal/adapter/messages/producers"
	mongo3 "github.com/gvillela7/rank-my-app/internal/adapter/repository/mongo"
	"github.com/gvillela7/rank-my-app/internal/core/ports"
	"github.com/gvillela7/rank-my-app/internal/core/usecase"
	"github.com/gvillela7/rank-my-app/internal/infra/database/mongo"
	"github.com/gvillela7/rank-my-app/internal/infra/rabbitmq"
	mongo2 "go.mongodb.org/mongo-driver/mongo"
	"go.uber.org/zap"
	"strconv"
)

// Injectors from wire.go:

func InitializeApp(ctx context.Context) (*App, func(), error) {
	mongoDBConnection, err := ProvideMongoConnection(ctx)
	if err != nil {
		return nil, nil, err
	}
	database, err := ProvideMongoDatabase(mongoDBConnection)
	if err != nil {
		return nil, nil, err
	}
	productRepository := ProvideProductRepository(database)
	productUseCase := ProvideProductUseCase(productRepository)
	validate := ProvideValidator()
	logger, err := ProvideLogger()
	if err != nil {
		return nil, nil, err
	}
	productHandler := ProvideProductHandler(productUseCase, validate, logger)
	orderRepository := ProvideOrderRepository(database)
	rabbitMQConnection, err := ProvideRabbitMQConnection(logger)
	if err != nil {
		return nil, nil, err
	}
	publishedOrderRepository := ProvidePublishedOrderRepository(database, logger)
	messageProducer, err := ProvideMessageProducer(rabbitMQConnection, publishedOrderRepository, logger)
	if err != nil {
		return nil, nil, err
	}
	orderUseCase := ProvideOrderUseCase(orderRepository, productRepository, messageProducer)
	orderHandler := ProvideOrderHandler(orderUseCase, validate, logger)
	healthHandler := ProvideHealthHandler(rabbitMQConnection)
	engine := ProvideRouter(productHandler, orderHandler, healthHandler, logger)
	app := ProvideApp(engine, mongoDBConnection, rabbitMQConnection)
	return app, func() {
	}, nil
}

// wire.go:

type App struct {
	Router       *gin.Engine
	DB           *mongo.MongoDBConnection
	RabbitMQConn *rabbitmq.RabbitMQConnection
}

func ProvideApp(router *gin.Engine, conn *mongo.MongoDBConnection, rabbitConn *rabbitmq.RabbitMQConnection) *App {
	return &App{
		Router:       router,
		DB:           conn,
		RabbitMQConn: rabbitConn,
	}
}

func ProvideMongoConnection(ctx context.Context) (*mongo.MongoDBConnection, error) {
	return mongo.NewMongoDBConnection(ctx)
}

func ProvideMongoDatabase(conn *mongo.MongoDBConnection) (*mongo2.Database, error) {
	return conn.Client()
}

func ProvideValidator() *validator.Validate {
	return validator.New()
}

func ProvideLogger() (*zap.Logger, error) {
	return zap.NewProduction()
}

func ProvideProductRepository(db *mongo2.Database) ports.ProductRepository {
	return mongo3.NewProductRepository(db)
}

func ProvideProductUseCase(repo ports.ProductRepository) ports.ProductUseCase {
	return usecase.NewProductUseCase(repo)
}

func ProvideProductHandler(uc ports.ProductUseCase, validator2 *validator.Validate, logger *zap.Logger) *handlers.ProductHandler {
	return handlers.NewProductHandler(uc, validator2, logger)
}

func ProvideOrderRepository(db *mongo2.Database) ports.OrderRepository {
	return mongo3.NewOrderRepository(db)
}

func ProvideOrderUseCase(orderRepo ports.OrderRepository, productRepo ports.ProductRepository, messageProducer ports.MessageProducer) ports.OrderUseCase {
	return usecase.NewOrderUseCase(orderRepo, productRepo, messageProducer)
}

func ProvideOrderHandler(uc ports.OrderUseCase, validator2 *validator.Validate, logger *zap.Logger) *handlers.OrderHandler {
	return handlers.NewOrderHandler(uc, validator2, logger)
}

func ProvideHealthHandler(rabbitConn *rabbitmq.RabbitMQConnection) *handlers.HealthHandler {
	return handlers.NewHealthHandler(rabbitConn)
}

func ProvideRouter(productHandler *handlers.ProductHandler, orderHandler *handlers.OrderHandler, healthHandler *handlers.HealthHandler, logger *zap.Logger) *gin.Engine {
	cfg := config.GetAPIConfig()
	return routes.SetupRouter(&routes.RouterConfig{
		ProductHandler: productHandler,
		OrderHandler:   orderHandler,
		HealthHandler:  healthHandler,
		Logger:         logger,
		AllowOrigin:    cfg.Origin,
		Environment:    cfg.Environment,
	})
}

func ProvideRabbitMQConnection(logger *zap.Logger) (*rabbitmq.RabbitMQConnection, error) {
	cfg := config.GetRabbitMQConfig()

	port, err := strconv.Atoi(cfg.Port)
	if err != nil {
		logger.Error("Invalid RabbitMQ port configuration", zap.String("port", cfg.Port), zap.Error(err))
		port = 5672
	}

	return rabbitmq.NewRabbitMQConnection(
		cfg.Host,
		port,
		cfg.Username,
		cfg.Password,
		cfg.VHost,
		logger,
	)
}

func ProvidePublishedOrderRepository(db *mongo2.Database, logger *zap.Logger) ports.PublishedOrderRepository {
	return mongo3.NewPublishedOrderRepository(db, logger)
}

func ProvideMessageProducer(rabbitConn *rabbitmq.RabbitMQConnection, publishedOrderRepo ports.PublishedOrderRepository, logger *zap.Logger) (ports.MessageProducer, error) {
	return producers.NewOrderProducer(rabbitConn, publishedOrderRepo, logger)
}
